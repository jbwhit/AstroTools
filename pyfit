#!/usr/bin/env python
# pyfit.py
# 
# The purpose of this program is to attempt to make fitting absorption systems 
# with vpfit reproducible, and easier. Several decisions were made that could
# be argued are steps in the wrong direction. Let me know if you have any better
# ideas or suggestions. (You can probably Google me and vpfit and find out my
# current information).
# 
# Copyright 2012 Jonathan Whitmore 
# Distributed under the Boost Software License, Version 1.0.
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated
# by a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
# NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
# DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,
# WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# 
import os
import sys
import re
import shutil
import argparse
import datetime
import time 
import pprint
import glob
import logging
import readline
import subprocess as subprocess
import difflib
from ConfigParser import SafeConfigParser
import simplejson as json

latestAtomdat = 'MM_VPFIT_2012-06-05.dat' # Update this. 
flagDict = {}
fitLevelDict = {}
hcd = {} # Housecleaning dictionary

# Known limitations
# datafiles must not have spaces in their names. 
# qa is the flag for fitting alpha.

def main():
  hcd['timeStamp'] = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S")
  print hcd['timeStamp']
  parser = argparse.ArgumentParser(description='Run vpfit with specified fitting parameters.')
  parser.add_argument('input13', action="store", default='fort.13', type=str) # Positional (feed in the fort.13-formatted file).
  parser.add_argument('--noComment', action="store_true", default=False, help='Turn off comment prompt.')
  parser.add_argument('--noConfigs', action="store_true", default=False, help='Will not use the config files.')
  parser.add_argument('--noPlot', action="store_true", default=False, help='Will not make pdf plots.')
  parser.add_argument('--noBump', action="store_true", default=False, help='Will not bump the fort.13 off the min values.')
  parser.add_argument('--noAlpha', action="store_true", default=False, help='Do not go on to fit for alpha.')
  parser.add_argument('--alphaLevel', action="store", default="notSet", type=str, help='With what fitLevel should alpha be fit?')
  parser.add_argument('--noLevelUp', action="store_true", default=False, help='Will not level up through the fitLevels.')
  parser.add_argument('--maxRuns', action="store", default=12, type=int, help='Max runs before quitting. Setting to 1 means no restarts.')
  parser.add_argument('--vpfit', action="store", dest="vpfitVersion", default='9.5', type=str, help='Which version of vpfit to use.')
  parser.add_argument('--levelProgression', action="store", default='L2,L3,L5', type=str, \
                      help='Type in comma separated (no spaces) list of the order of the ways "leveling up" should go. ex: L2,L4,L5')
  parser.add_argument('--fitLevel', default='L5', help='The VPFIT parameter step sizes to use.')
  parser.add_argument('--dataFile', action="store", default='blind', help='data file to use.')
  parser.add_argument('--fitSetupDirectory', dest="fitSetupDirectory", default='notSet', help='Location of atom.dat, vp_setup.dat, etc.')
  parser.add_argument('--atomdat', choices=('isoAtomFile', 'atomFile'), default='atomFile', help='atom.dat choices')
  parser.add_argument('--version', action='version', version='%(prog)s 0.0004')
  args = parser.parse_args()
  if args.vpfitVersion == ("9.5" or "95"):
    print "VPFIT version: ", args.vpfitVersion
    hcd['vpfitExecutable'] = 'vpfit95'
  elif args.vpfitVersion == ("10.0" or "10"):
    print "VPFIT version: ", 
    hcd['vpfitExecutable'] = 'vpfit10'
  else:
    print "What VPFIT version are you wanting to use?"
  flagDict['noLevelUp'] = args.noLevelUp
  flagDict['noComment'] = args.noComment
  flagDict['noConfigs'] = args.noConfigs
  flagDict['noAlpha'] = args.noAlpha
  flagDict['noBump'] = args.noBump
  flagDict['noPlot'] = args.noPlot
  flagDict['iterations125'] = False
  
  os.makedirs(hcd['timeStamp'])
  hcd['parentDirectory'] = os.getcwd() + '/'
  os.chdir(hcd['timeStamp'])
  hcd['fitDirectory'] = os.getcwd() + '/'

  # Create a fitting log.
  logging.basicConfig(filename=hcd['timeStamp'] + '.log', level=logging.DEBUG)
  for arg, value in sorted(vars(args).items()):
    logging.info("Argument %s: %r", arg, value)

  logging.info("hcd['parentDirectory']: " + hcd['parentDirectory'])
  logging.info("hcd['fitDirectory']: " + hcd['fitDirectory'])

  if args.noConfigs == True:
    print "Not using config files."
    print "Need to know locations of setup files and data files."
  else:
    parser = SafeConfigParser()
    found = parser.read(glob.glob(hcd['parentDirectory'] + 'config*'))
    print "Using these config files:"
    for configfile in set(found):
      print "  ", configfile
      logging.info("config loaded: " + configfile)
    hcd['setupDir'] = parser.get('machine', 'setupdir') + '/'
    hcd['atomDatFile'] = parser.get('update', args.atomdat)
    shutil.copy(hcd['setupDir'] + hcd['atomDatFile'], hcd['fitDirectory'])
    shutil.copy(hcd['setupDir'] + 'vp_setup.dat', hcd['fitDirectory'])
    shutil.copy(hcd['setupDir'] + 'vp_splot.dat', hcd['fitDirectory'])
    hcd['dataDirectory'] = parser.get('data', 'dataDirectory') + '/'
    os.symlink(hcd['atomDatFile'], 'atom.dat') # create symbolic link to atom.dat in fitting directory.

  shutil.copy(hcd['parentDirectory'] + args.input13, hcd['fitDirectory'] + "input.fort.13")
  if args.input13 != "input.fort.13":
    shutil.copy(hcd['parentDirectory'] + args.input13, hcd['fitDirectory'] + "input.fort.13")

  if flagDict['noBump']:
    "Not bumping values. Hope this is what you want."
    shutil.copy('input.fort.13', hcd['fitDirectory'] + 'bump.13')
  else:
    bump('input.fort.13', 'bump.13')

  d = difflib.Differ()
  diff = difflib.unified_diff(open('input.fort.13', 'r').read().split('\n'), open('bump.13','r').read().split('\n'), n=0)
  print '\n'.join(diff)
  diff = difflib.unified_diff(open('input.fort.13', 'r').read().split('\n'), open('bump.13','r').read().split('\n'), n=0)
  logging.info( "diff begin " )
  logging.info( '\n'.join(diff))
  logging.info( "diff end " )

  dataFiles = []
  with open('bump.13', 'r') as bumpFile:
    beginHead, beginBody = False, False
    with open('head.13', 'w') as head, open('body.13', 'w') as body:
      for line in bumpFile.read().splitlines():
        if (not line.strip().startswith('!') and (line.strip() != '')): # Ignore comments and empty lines.
          if line.startswith('   *'):
            beginHead = True
          if beginHead == True:
            print >>head, line
            if len(line.split()) > 4:
              dataFiles.append(line.split()[0])
          if beginBody == True:
            print >>body, line
          if line.startswith('  *'):
            beginHead = False
            beginBody = True
  # combine head and body into fort.13
  with open('fort.13', 'w') as outFile:
    with open('head.13','r') as head, open('body.13','r') as body:
      outFile.write(head.read())
      outFile.write(body.read())

  logging.info("Data files used: ")
  for datafile in set(dataFiles):
    os.symlink(hcd['dataDirectory'] + datafile, hcd['fitDirectory'] + datafile)
    logging.info(datafile)

  # TODO make these the fort13flagcheck outputs get logged as errors/warnings in logger.
  # Parses the body of the body.13 for any anomalies.
  p = subprocess.call('fort13flagcheck') # waits for return.
  
  # Create dictionary of all level strings; use args.fitLevel as key.
  fitLevelDict["L1"] = "f\nil\ncs\n2.e-4 100.0 2.e-4\nn\n0.01 \nb\n0.2 \nz\n2.e-6\nx4\n5.e-6\n\n\nfort.13\nn\nn\n\n"
  fitLevelDict["L2"] = "f\nil\ncs\n2.e-5 100.0 2.e-5\nn\n0.005\nb\n0.1 \nz\n2.e-7\nx4\n5.e-6\n\n\nfort.13\nn\nn\n\n"
  fitLevelDict["L3"] = "f\nil\ncs\n2.e-6 100.0 2.e-6\nn\n0.002\nb\n0.05\nz\n2.e-7\nx4\n5.e-7\n\n\nfort.13\nn\nn\n\n"
  fitLevelDict["L4"] = "f\nil\ncs\n2.e-7 100.0 2.e-7\nn\n0.002\nb\n0.05\nz\n2.e-7\nx4\n5.e-7\n\n\nfort.13\nn\nn\n\n"
  fitLevelDict["L5"] = "f\nil\ncs\n1.e-8 100.0 1.e-8\nn\n0.002\nb\n0.05\nz\n2.e-7\nx4\n5.e-7\n\n\nfort.13\nn\nn\n\n"
  fitLevelDict["M6"] = "f\nil\ncs\n1.e-8 100.0 1.e-8\nn\n0.01 \nb\n0.1 \nz\n2.e-6\nx4\n5.e-6\n\n\nfort.13\nn\nn\n\n"
  fitLevelDict["M7"] = "f\nil\ncs\n1.e-7 100.0 1.e-8\nn\n0.01 \nb\n0.1 \nz\n2.e-6\nx4\n5.e-6\n\n\nfort.13\nn\nn\n\n"
  fitLevelDict["M8"] = "f\nil\ncs\n1.e-6 100.0 1.e-8\nn\n0.01 \nb\n0.1 \nz\n2.e-6\nx4\n5.e-6\n\n\nfort.13\nn\nn\n\n"
  fitLevelDict['levelProgression'] = args.levelProgression.split(',') # store levelProgression as array in fitLevelDict
  print "levelProgression: ", fitLevelDict['levelProgression']
  fitLevelDict['maxRuns'] = int(args.maxRuns)
  fitLevelDict['currentFitLevel'] = args.fitLevel
  fitLevelDict['maxLevel'] = fitLevelDict['levelProgression'][-1]
  fitLevelDict['currentParameterString'] = fitLevelDict[fitLevelDict['currentFitLevel']]
  if fitLevelDict['currentFitLevel'] not in fitLevelDict['levelProgression']:
    print "fitLevel not found in levelProgression. (Problem if progressing...)."
  if args.alphaLevel == "notSet":
    fitLevelDict["alphaLevel"] = fitLevelDict['levelProgression'][-1]
  else:
    if args.alphaLevel in fitLevelDict:
      fitLevelDict["alphaLevel"] = args.alphaLevel
    else:
      print "What alphaLevel are you trying to use? I see: ", args.alphaLevel
  
  # Create symbolic link to fitting directory.
  hcd['executableLink'] = subprocess.Popen(['which', hcd['vpfitExecutable']], stdout=subprocess.PIPE)
  os.symlink(hcd['executableLink'].communicate()[0].strip(), hcd['fitDirectory'] + 'vpfit')
  logging.info('VPFIT version: ' + args.vpfitVersion)
  logging.info('VPFIT executable: ' + hcd['vpfitExecutable'])

  # Change to use current directory settings. 
  os.environ['ATOMDIR'] = 'atom.dat'
  os.environ['VPFSETUP'] = 'vp_setup.dat'
  os.environ['VPFPLOTS'] = 'vp_splot.dat'
  logging.info("PATH for ATOMDIR:  " + os.environ['ATOMDIR'])
  logging.info("PATH for VPFSETUP: " + os.environ['VPFSETUP'])
  logging.info("PATH for VPFPLOTS: " + os.environ['VPFPLOTS'])

  with open('command.info', 'w') as fh:
    print >>fh, "! ATOMDIR:" + hcd['atomDatFile']
    print >>fh, "! runCommand: printf " + repr(fitLevelDict['currentParameterString']) + " | " + hcd['vpfitExecutable']
  with open('rerun.bash', 'w') as fh:
    print >>fh, "#!/bin/bash\nexport ATOMDIR=", os.environ['ATOMDIR'], "\nexport VPFSETUP=", os.environ['VPFSETUP'], \
      "\nexport VPFPLOTS=", os.environ['VPFPLOTS'], "\ncp ", hcd['timeStamp'] + ".fort.13 fort.13", \
      "\nprintf " + repr(fitLevelDict['currentParameterString']) + " | " + hcd['vpfitExecutable']
    
  # cat command.info fort.13 > command.fort.13
  with open('command.fort.13', 'w') as outFile:
    with open('command.info', 'r') as com, open('fort.13', 'r') as fort13:
      outFile.write(com.read())
      outFile.write(fort13.read())

  logging.info("Fitting Parameters: " + repr(fitLevelDict['currentParameterString']))

  if args.noComment == False:
    initialFitComment = raw_input("Comment: ")
    logging.info("Comment: " + initialFitComment)
  
  fitLevelDict['continueTimeStamp'] = []
  fitLevelDict['continueTimeStamp'].append(hcd['timeStamp'])
  runVPFIT(startFort13='command.fort.13')
  fort18Check('fort.18')
  fitLevelDict['runCount'] = 1
  if fitLevelDict['maxRuns'] < 2:
    "No restarts."
  elif (flagDict['iterations125'] == True) or (flagDict['noLevelUp'] == False):
    flagDict['rerunFlag'] = True
    reRunFit()
  
  if flagDict['noPlot'] == False: 
    print "Creating fit comparison plots."
    proc = subprocess.Popen(['plotfit', fitLevelDict['continueTimeStamp'][-1], 'input.fort.13', fitLevelDict['continueTimeStamp'][-1] + ".fit.13"])

  flagDict['alphaAlreadyFit'] = False
  with open(fitLevelDict['continueTimeStamp'][-1] + '.fit.13', 'r') as finalFit13:
    if re.search('qa', finalFit13.read()):
      flagDict['alphaAlreadyFit'] = True # If already started out fitting for alpha
  
  if (flagDict['noAlpha'] == False) and (flagDict['alphaAlreadyFit'] == False): 
    print "Fitting for alpha..."
    p3 = subprocess.call(['convert13-13da', fitLevelDict['continueTimeStamp'][-1] + '.fit.13'])
    flagDict['noLevelUp'] = True
    fitLevelDict['currentFitLevel'] = fitLevelDict["alphaLevel"]
    time.sleep(2) # ensures a different timestamp for the alpha fit
    hcd['newTimeStamp'] = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S") + '.alpha'
    fitLevelDict['continueTimeStamp'].append( hcd['newTimeStamp'] )
    shutil.move('alpha.13', hcd['newTimeStamp'] + '.fit.13')
    print hcd['newTimeStamp'] + '.fit.13'
    flagDict['rerunFlag'] = True
    reRunFit(tag='.alpha')
  
  print "Program exited gracefully."
  print hcd['timeStamp']
  pass

def reRunFit(tag=''):
  """docstring for reRunFit"""
  print "Resetting runCount"
  fitLevelDict['runCount'] = 0
  while flagDict['rerunFlag'] == True:
    flagDict['rerunFlag'] = False
    fitLevelDict['runCount'] += 1
    print "Level: ", fitLevelDict['currentFitLevel']
    print "Restart: ", fitLevelDict['runCount']
    hcd['newTimeStamp'] = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S") + tag
    fitLevelDict['continueTimeStamp'].append(hcd['newTimeStamp'])
    logging.info("Beginning run: " + str(fitLevelDict['runCount']) + " at " + hcd['newTimeStamp'])
    print "Beginning run: " + str(fitLevelDict['runCount']) + " at " + hcd['newTimeStamp'] + " in " + fitLevelDict['continueTimeStamp'][0]
    if flagDict['noBump']:
      "Not bumping values. Hope this is what you want."
      shutil.copy(fitLevelDict['continueTimeStamp'][-2] + '.fit.13', hcd['fitDirectory'] + 'bump.13')
    else:
      bump(fitLevelDict['continueTimeStamp'][-2] + '.fit.13', 'fort.13')
    shutil.copy('fort.13', fitLevelDict['continueTimeStamp'][-1] + '.fort.13')
    runVPFIT(startFort13='fort.13')
    fort18Check('fort.18')
    if flagDict['iterations125'] == True:
      if fitLevelDict['runCount'] < fitLevelDict['maxRuns']:
        flagDict['rerunFlag'] = True
        continue
    elif (fitLevelDict['levelProgression'].index(fitLevelDict['currentFitLevel']) < len(fitLevelDict['levelProgression']) - 1) and (flagDict['noLevelUp'] == False):
      print "Level up; run count reset."
      fitLevelDict['currentFitLevel'] = fitLevelDict['levelProgression'][fitLevelDict['levelProgression'].index(fitLevelDict['currentFitLevel']) + 1]
      fitLevelDict['runCount'] = 0
      flagDict['rerunFlag'] = True
      continue
    elif fitLevelDict['levelProgression'].index(fitLevelDict['currentFitLevel']) == len(fitLevelDict['levelProgression']) - 1:
      print "Less than 125 iterations; currentFitLevel is maxLevel; converged!"
      logging.info("It took " + str(fitLevelDict['runCount']) + " runs to converge.")
      continue
    else:
      print "Did not converge after: ", fitLevelDict['runCount']
      logging.warning("Not converged yet. Runs before stopping: " + str(fitLevelDict['runCount']))
      continue
  pass

def runVPFIT(startFort13='command.fort.13'):
  """docstring for runVPFIT"""
  print "Running... "
  if startFort13 != 'fort.13':
    shutil.copy(startFort13, 'fort.13')
  startTime = datetime.datetime.now()
  logging.info("Fitting Parameters: " + repr(fitLevelDict['currentParameterString']))
  proc = subprocess.Popen([hcd['vpfitExecutable']], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
  result = proc.communicate(input=fitLevelDict['currentParameterString'])
  endTime = datetime.datetime.now()
  runningTime = endTime - startTime
  print "Running time:", runningTime.__str__()
  logging.info("Time to execute: " + runningTime.__str__())
  p2 = subprocess.call(['combine2613', 'fort.13', 'fort.26', 'fit.13'])
  shutil.copy('fort.18', fitLevelDict['continueTimeStamp'][-1] + '.fort.18')
  shutil.copy('fort.26', fitLevelDict['continueTimeStamp'][-1] + '.fort.26')
  shutil.copy('fit.13', fitLevelDict['continueTimeStamp'][-1] + '.fit.13')
  pass


def fort18Check(inFile):
  """
  Runs the inFile through a series of checks to test if anything 
  bad has happened during the fit. 
  """
  # check (chi-sq going down every iteration; error not "too big"; value not "too big")
  iterationArray = []
  starts = []
  rejected = []
  hessian = []
  dropped = []
  flagDict['iterations125'] = False
  with open(inFile, 'r') as f18:
    for line in f18.read().splitlines():
      if re.search('iteration', line):
        iterationArray.append(line.split()[2])
        starts.append(line.split()[4])
      if re.search('rejected', line):
        rejected.append(line)
      if re.search('hessian', line):
        hessian.append(line)
      if re.search('iteration', line):
        dropped.append(line)
  if int(max(set(starts))) >= 2:
    logging.warning("Initial fort.18 restarts: " + str(set(starts)))
  if int(iterationArray[-1]) == 125:
    flagDict['iterations125'] = True
    logging.info("125 iterations.")
  pass

def pyAnalysis3(inFile='fort.26'):
  """docstring for pyAnalysis3"""
  # echo "iter;  chisq;    Npix;   DoF; Ndropped; Filename"
  print "Iter; chisq; Npix; DoF; Params; Ndrop; Filename"
  # TODO print # parameters fit. 
  # awk '/Stat/{printf("%3i  %3.7f %6i %6i %6i     %s\n"), $3, $4, $5, $6, $8, FILENAME}' 201*/*fit.13 
  if not re.search('qa', open(inFile).read()):
    for line in open(inFile).readlines():
      if re.search('Stat', line):
        parseThis = line.split()
        print parseThis[2], parseThis[3], parseThis[4], parseThis[5], int(parseThis[4]) - int(parseThis[5]), parseThis[7], inFile 
  else:
    for line in open(inFile).readlines():
      if re.search('Stat', line):
        parseThis = line.split()
        print parseThis[2], parseThis[3], parseThis[4], parseThis[5], int(parseThis[4]) - int(parseThis[5]), parseThis[7], inFile,
      if re.search('qa', line):
        print line.split()[3], line.split()[4]
  pass

def fort26check():
  """docstring for fort26check"""
  # Errors in fort.26 to parse for:
  # Stats: ... errs 
  # Stats: ... BAD
  # # echo "iter;  chisq;    Npix;   DoF; Ndropped; Filename; level; alpha-fit"
  # awk '/Stat/{printf("%3i  %3.7f %6i %6i %6i     %s \n"), $3, $4, $5, $6, $8, "'$hcd['timeStamp']'" "/" FILENAME}' fit.13 | paste - fit.log > temp
  # awk '/qa/{print "alpha"}' fit.13 | paste temp - > summary.txt
  pass

def bump(inFile, outFile):
  """
  Takes inFile and bumps the values of the bvalues that have hit the limit.
  """
  with open(inFile, 'r') as unBumped, open(outFile, 'w') as bumpFile:
    for line in unBumped.readlines():
      bumpFile.write(re.sub(r' 0.5000', ' 0.6250', line))
  pass

if __name__ == '__main__':
  main()


# # TODO parse the body of fort.13 and fit.13 files and report any discrepancies. 
# # TODO Create pdf of full velocity plot.
# # TODO find some way to parse things that won't change (fit results, time, date) plus things
# # TODO Add LaTeX comment (or json dictionary)
# TODO fix bug: if select fitLevel that isn't in the "progression" but don't select alphaFit it 
# TODO fix superjob bug where it doesn't fit for alpha... 
# TODO Add command line comment.
# TODO Estimate stopping criteria by looking at DoF, etc. 

# -----------------------
# Higher level: physical components are the structures, the particular metals are not important. Abundance ratios are interesting.
# End-run analysis should be a separate program so can be rerun separately/repeatedly ?
# stochastic shifting of every fit variable and restart of fitting process.
# -----------------------
# data = [{"running time": runningTime}]
# json
# Parse datafile -- report/log if blind or unblind. 