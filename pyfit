#!/usr/bin/env python
# pyfit.py
# 
# The purpose of this program is to attempt to make fitting absorption systems 
# with vpfit reproducible, and easier. Several decisions were made that could
# be argued are steps in the wrong direction. Let me know if you have any better
# ideas or suggestions. (You can probably Google me and vpfit and find out my
# current information).
# 
# Copyright 2012 Jonathan Whitmore 
# Distributed under the Boost Software License, Version 1.0.
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated
# by a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
# NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
# DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,
# WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# 
import os
import sys
import re
import shutil
import argparse
import shlex
import datetime
import time 
import pprint
import glob
import logging
import readline
import subprocess as subprocess
import difflib
from ConfigParser import SafeConfigParser
import simplejson as json

latestAtomdat = 'MM_VPFIT_2012-06-05.dat' # Update this. 

# Known limitations
# datafiles must not have spaces in their names. 
# qa is the flag for fitting alpha.

def main():
  TIMESTAMP = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S")
  print TIMESTAMP

  parser = argparse.ArgumentParser(description='Run vpfit with specified fitting parameters.')
  parser.add_argument('input13', action="store", default='fort.13', type=str) # Positional (feed in the fort.13-formatted file).
  parser.add_argument('--noContinue', action="store_true", default=False, help='Will not continue with alpha fitting.')
  parser.add_argument('--noLevelUp', action="store_true", default=False, help='Will not level up through the fitLevels.')
  parser.add_argument('--noComment', action="store_true", default=False, help='Turn off comment prompt.')
  parser.add_argument('--noConfigs', action="store_true", default=False, help='Will not use the config files.')
  parser.add_argument('--noPlot', action="store_true", default=False, help='Will not make pdf plots.')
  parser.add_argument('--noBump', action="store_true", default=False, help='Will not bump the fort.13 off the min values.')
  parser.add_argument('--noAlpha', action="store_true", default=False, help='Do not go on to fit for alpha.')
  parser.add_argument('--vpfit', action="store", dest="vpfitVersion", default='9.5', type=str, help='Which version of vpfit to use.')
  parser.add_argument('--fitLevel', choices=('L1', 'L2', 'L3', 'L4', 'L5'), default='L5', 
                      help='The VPFIT parameter step sizes to use.')
  parser.add_argument('--dataFile', action="store", default='blind', help='data file to use.')
  parser.add_argument('--maxRuns', action="store", default=12, type=int, help='Max runs before quitting.')
  parser.add_argument('--fitSetupDirectory', dest="fitSetupDirectory", default='notSet', help='Location of atom.dat, vp_setup.dat, etc.')
  parser.add_argument('--atomdat', choices=('isoAtomFile', 'atomFile'), default='atomFile', help='atom.dat choices')
  parser.add_argument('--version', action='version', version='%(prog)s 0.0003')
  args = parser.parse_args()
  
  if args.vpfitVersion == ("9.5" or "95"):
    print "VPFIT version: ", args.vpfitVersion
    vpfitExecutable = 'vpfit95'
  elif args.vpfitVersion == ("10.0" or "10"):
    print "VPFIT version: ", 
    vpfitExecutable = 'vpfit10'
  else:
    print "What VPFIT version are you wanting to use?"
  
  flagDict = {}  
  flagDict['noContinue'] = args.noContinue
  flagDict['noLevelUp'] = args.noLevelUp
  flagDict['noComment'] = args.noComment
  flagDict['noConfigs'] = args.noConfigs
  flagDict['iterations125'] = False

  os.makedirs(TIMESTAMP)
  parentDirectory = os.getcwd() + '/'
  os.chdir(TIMESTAMP)
  fitDirectory = os.getcwd() + '/'

  # Create a fitting log.
  logging.basicConfig(filename=TIMESTAMP + '.log', level=logging.DEBUG)
  for arg, value in sorted(vars(args).items()):
    logging.info("Argument %s: %r", arg, value)

  logging.info("parentDirectory: " + parentDirectory)
  logging.info("fitDirectory: " + fitDirectory)

  if args.noConfigs == True:
    print "Not using config files."
    print "Need to know locations of setup files and data files."
  else:
    parser = SafeConfigParser()
    candidates = glob.glob(parentDirectory + 'config*')
    found = parser.read(candidates)
    print "Using these config files:"
    for configfile in set(found):
      print "  ", configfile
      logging.info("config loaded: " + configfile)
    setupDir = parser.get('machine', 'setupdir') + '/'
    atomDatFile = parser.get('update', args.atomdat)
    shutil.copy(setupDir + atomDatFile, fitDirectory)
    shutil.copy(setupDir + 'vp_setup.dat', fitDirectory)
    shutil.copy(setupDir + 'vp_splot.dat', fitDirectory)
    dataDirectory = parser.get('data', 'dataDirectory') + '/'
    os.symlink(atomDatFile, 'atom.dat') # create symbolic link to atom.dat in fitting directory.

  shutil.copy(parentDirectory + args.input13, fitDirectory + "input.fort.13")
  if args.input13 != "input.fort.13":
    shutil.copy(parentDirectory + args.input13, fitDirectory + "input.fort.13")

  if args.noBump:
    shutil.copy('input.fort.13', fitDirectory + 'bump.13')
  else:
    bump('input.fort.13', 'bump.13')

  d = difflib.Differ()
  diff = difflib.unified_diff(open('input.fort.13', 'r').read().split('\n'), open('bump.13','r').read().split('\n'), n=0)
  print '\n'.join(diff)
  diff = difflib.unified_diff(open('input.fort.13', 'r').read().split('\n'), open('bump.13','r').read().split('\n'), n=0)
  logging.info( "diff begin " )
  logging.info( '\n'.join(diff))
  logging.info( "diff end " )

  inputHandle = open('bump.13', 'r').read().split('\n')
  beginHead, beginBody = False, False
  try: 
    with open('head.13', 'w') as head, open('body.13', 'w') as body:
      for line in inputHandle:
        if (not line.strip().startswith('!') and line.strip() != ''): # Ignore comments and empty lines.
          if line.startswith('   *'):
            beginHead = True
          if beginHead == True:
            print >>head, line
          if beginBody == True:
            print >>body, line
          if line.startswith('  *'):
            beginHead = False
            beginBody = True
  except: 
    print "Splitting the input file failed."

  # combine head and body into fort.13
  with open('fort.13', 'w') as outFile:
    with open('head.13','r') as head, open('body.13','r') as body:
      outFile.write(head.read())
      outFile.write(body.read())

  # parse input fort.13 for data files needed. 
  dataFiles = []
  with open ('head.13', 'r') as head:
    for line in head.read().split('\n'):
      if len(line.split()) > 4:
        dataFiles.append(line.split()[0])
  logging.info("Data files used: ")
  for datafile in set(dataFiles):
    os.symlink(dataDirectory + datafile, fitDirectory + datafile)
    logging.info(datafile)

  # Parses the body of the body.13 for any anomalies.
  p = subprocess.call('fort13flagcheck') # waits for return.

  # Create dictionary of all level strings; use args.fitLevel as key.
  fitLevelDictionary = {}
  fitLevelDictionary["L1"] = "f\nil\ncs\n2.e-4 100.0 2.e-4\nn\n0.01 \nb\n0.2 \nz\n2.e-6\nx4\n5.e-6\n\n\nfort.13\nn\nn\n\n"
  fitLevelDictionary["L2"] = "f\nil\ncs\n2.e-5 100.0 2.e-5\nn\n0.005\nb\n0.1 \nz\n2.e-7\nx4\n5.e-6\n\n\nfort.13\nn\nn\n\n"
  fitLevelDictionary["L3"] = "f\nil\ncs\n2.e-6 100.0 2.e-6\nn\n0.002\nb\n0.05\nz\n2.e-7\nx4\n5.e-7\n\n\nfort.13\nn\nn\n\n"
  fitLevelDictionary["L4"] = "f\nil\ncs\n2.e-7 100.0 2.e-7\nn\n0.002\nb\n0.05\nz\n2.e-7\nx4\n5.e-7\n\n\nfort.13\nn\nn\n\n"
  fitLevelDictionary["L5"] = "f\nil\ncs\n1.e-8 100.0 1.e-8\nn\n0.002\nb\n0.05\nz\n2.e-7\nx4\n5.e-7\n\n\nfort.13\nn\nn\n\n"

  FITTINGPARAMETERS = fitLevelDictionary[args.fitLevel]
  levelArray = sorted(fitLevelDictionary.keys())
  maxRuns = args.maxRuns
  for level, s in enumerate(levelArray):
    if args.fitLevel in s:
      currentLevel = level
  maxLevel = levelArray[-1]
  print "Max fitting level is: ", maxLevel
  
  # Create symbolic link to fitting directory.
  executableLink = subprocess.Popen(['which', vpfitExecutable], stdout=subprocess.PIPE)
  os.symlink(executableLink.communicate()[0].strip(), fitDirectory + 'vpfit')
  logging.info('VPFIT version: ' + args.vpfitVersion)
  logging.info('VPFIT executable: ' + vpfitExecutable)

  # Change to use current directory settings. 
  os.environ['ATOMDIR'] = 'atom.dat'
  os.environ['VPFSETUP'] = 'vp_setup.dat'
  os.environ['VPFPLOTS'] = 'vp_splot.dat'
  logging.info("PATH for ATOMDIR:  " + os.environ['ATOMDIR'])
  logging.info("PATH for VPFSETUP: " + os.environ['VPFSETUP'])
  logging.info("PATH for VPFPLOTS: " + os.environ['VPFPLOTS'])

  with open('command.info', 'w') as fh:
    print >>fh, "! ATOMDIR:" + atomDatFile
    print >>fh, "! runCommand: printf " + repr(FITTINGPARAMETERS) + " | " + vpfitExecutable

  # cat command.info fort.13 > command.fort.13
  with open('command.fort.13', 'w') as outFile:
    with open('command.info', 'r') as com, open('fort.13', 'r') as fort13:
      outFile.write(com.read())
      outFile.write(fort13.read())

  logging.info("Fitting Parameters: " + repr(FITTINGPARAMETERS))
  print TIMESTAMP
  if args.noComment == False:
    initialFitComment = raw_input("Comment: ")
    logging.info(initialFitComment)

  print TIMESTAMP
  runVPFIT(vpfitExecutable, FITTINGPARAMETERS, TIMESTAMP)
  fort18Check('fort.18', flagDict)
  
  RUNCOUNT = 0
  CONTINUETIMESTAMP = []
  CONTINUETIMESTAMP.append(TIMESTAMP)
  rerunFlag = False
  if (flagDict['iterations125'] == True) or (currentLevel < levelArray.index(maxLevel)):
    rerunFlag = True
  
  # TODO Create rerun and levelup function. 
  while rerunFlag == True:
    print "Test: 125flag: ", flagDict['iterations125']
    print "Test: RUNCOUNT: ", RUNCOUNT
    print "Test: currentLevel: ", levelArray[currentLevel]
    if ((flagDict['iterations125'] == True) and (RUNCOUNT < maxRuns)):
      print "Branch A"
      RUNCOUNT += 1
      print "125 iterations, restarting..."
      print "currentLevel: " , levelArray[currentLevel]
      print "Restart: ", RUNCOUNT
      NEWTIMESTAMP = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S")
      CONTINUETIMESTAMP.append(NEWTIMESTAMP)
      logging.info("Beginning run: " + str(RUNCOUNT) + " at " + NEWTIMESTAMP)
      print "Beginning run: " + str(RUNCOUNT) + " at " + NEWTIMESTAMP + " in " + TIMESTAMP
      bump(CONTINUETIMESTAMP[-2] + '.fit.13', 'fort.13')
      runVPFIT(vpfitExecutable, fitLevelDictionary[levelArray[currentLevel]], CONTINUETIMESTAMP[-1])
      fort18Check('fort.18', flagDict)
    elif (flagDict['iterations125'] == False) and (currentLevel < levelArray.index(maxLevel)):
      print "Branch B"
      currentLevel += 1
      RUNCOUNT = 0
      flagDict['iterations125'] = True # To fool the flag to restart things. 
      print "Level up; RUNCOUNT reset."
      logging.info("Leveled up!")
      logging.info("Fitting Parameters: " + repr(fitLevelDictionary[levelArray[currentLevel]]))
      continue
    elif (flagDict['iterations125'] == False) and (currentLevel == levelArray.index(maxLevel)):
      print "Branch C"
      print "Less than 125 iterations."
      print "currentLevel is maxLevel"
      print "converged!"
      logging.info("It took " + str(RUNCOUNT) + " runs to converge.")
      rerunFlag = False
      continue
    else:
      print "Branch D"
      print "Did not converge after: ", RUNCOUNT
      logging.warning("Not converged yet. Runs before stopping: " + str(RUNCOUNT))
      rerunFlag = False
      continue
    
  if args.noPlot == False: 
    print "Creating fit comparison plots."
    proc = subprocess.Popen(['plotfit', CONTINUETIMESTAMP[-1], 'input.fort.13', CONTINUETIMESTAMP[-1] + ".fit.13"])

  alphafit = False
  with open(CONTINUETIMESTAMP[-1] + '.fit.13', 'r') as finalFit13:
    if re.search('qa', finalFit13.read()):
      alphafit = True # If already started out fitting for alpha

  # Add argparse option to say which fittingflag would fit for alpha
  # Add LaTeX comment (or json dictionary)
  if (args.noAlpha == False) and (alphafit == False): 
    print "Fitting for alpha..."
    p3 = subprocess.call(['convert13-13da', CONTINUETIMESTAMP[-1] + '.fit.13'])
    NEWTIMESTAMP = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S") + '.alpha'
    CONTINUETIMESTAMP.append( NEWTIMESTAMP )
    shutil.move('alpha.13', NEWTIMESTAMP + '.fit.13')
    print NEWTIMESTAMP + '.fit.13'
    rerunFlag = True
    RUNCOUNT = 0
    currentLevel = levelArray.index(maxLevel)
    flagDict['iterations125'] = True
    while rerunFlag == True:
      if ((flagDict['iterations125'] == True)  and (RUNCOUNT < maxRuns)):
        RUNCOUNT += 1
        print "Restarting."
        print "flagDict['iterations125']: ", flagDict['iterations125']
        print "currentLevel: " , currentLevel
        print "RUNCOUNT: ", RUNCOUNT
        NEWTIMESTAMP = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S") + '.alpha'
        CONTINUETIMESTAMP.append(NEWTIMESTAMP)
        logging.info("Beginning run: " + str(RUNCOUNT) + " at " + NEWTIMESTAMP)
        print "Beginning run: " + str(RUNCOUNT) + " at " + NEWTIMESTAMP
        bump(CONTINUETIMESTAMP[-2] + '.fit.13', 'fort.13')
        runVPFIT(vpfitExecutable, fitLevelDictionary[levelArray[currentLevel]], CONTINUETIMESTAMP[-1])
        fort18Check('fort.18', flagDict)
      elif (flagDict['iterations125'] == False) and (currentLevel < levelArray.index(maxLevel)):
        currentLevel += 1
        RUNCOUNT = 0
        flagDict['iterations125'] = True # To fool the flag to restart things. 
        print "Level up; RUNCOUNT reset."
        logging.info("Leveled up!")
        logging.info("Fitting Parameters: " + fitLevelDictionary[levelArray[currentLevel]])
        continue
      elif (flagDict['iterations125'] == False) and (currentLevel == levelArray.index(maxLevel)):
        print "Less than 125 iterations."
        print "currentLevel is maxLevel"
        print "converged!"
        logging.info("It took " + str(RUNCOUNT) + " runs to converge.")
        rerunFlag = False
        continue
      else:
        print "Did not converge after: ", RUNCOUNT
        logging.warning("Not converged yet. Runs before stopping: " + str(RUNCOUNT))
        rerunFlag = False
        continue

  print "Exited gracefully."
  print TIMESTAMP
  pass

def fort18Check(inFile, passDictionary):
  """
  Runs the inFile through a series of checks to test if anything 
  bad has happened during the fit. 
  """
  # check (chi-sq going down every iteration; error not "too big"; value not "too big")
  # TODO: levelUp flag; continueFlag; etc. 
  iterationArray = []
  starts = []
  rejected = []
  hessian = []
  dropped = []
  passDictionary['iterations125'] = False
  with open(inFile, 'r') as f18:
    for line in f18.read().splitlines():
      if re.search('iteration', line):
        iterationArray.append(line.split()[2])
        starts.append(line.split()[4])
      if re.search('rejected', line):
        rejected.append(line)
      if re.search('hessian', line):
        hessian.append(line)
      if re.search('iteration', line):
        dropped.append(line)
  if int(max(set(starts))) >= 2:
    logging.warning("Initial fort.18 restarts: " + str(set(starts)))
  if int(iterationArray[-1]) == 125:
    passDictionary['iterations125'] = True
    logging.info("125 iterations.")
  else:
    continueFlag = False
  pass

def fort26check():
  """docstring for fort26check"""
  # Errors in fort.26 to parse for:
  # Stats: ... errs 
  # Stats: ... BAD
  # # echo "iter;  chisq;    Npix;   DoF; Ndropped; Filename; level; alpha-fit"
  # awk '/Stat/{printf("%3i  %3.7f %6i %6i %6i     %s \n"), $3, $4, $5, $6, $8, "'$TIMESTAMP'" "/" FILENAME}' fit.13 | paste - fit.log > temp
  # awk '/qa/{print "alpha"}' fit.13 | paste temp - > summary.txt
  pass

def bump(inFile, outFile):
  """
  Takes inFile and bumps the values of the bvalues that have hit the limit.
  """
  with open(inFile, 'r') as unBumped, open(outFile, 'w') as bumpFile:
    for line in unBumped.readlines():
      bumpFile.write(re.sub(r' 0.5000', ' 0.6250', line))
  pass

def runVPFIT(vpfitExecutable, FITTINGPARAMETERS, prependStamp):
  """docstring for runVPFIT"""
  print "Running... "
  shutil.copy('command.fort.13', prependStamp + '.fort.13')
  startTime = datetime.datetime.now()
  proc = subprocess.Popen([vpfitExecutable], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
  result = proc.communicate(input=FITTINGPARAMETERS)
  endTime = datetime.datetime.now()
  runningTime = endTime - startTime
  print "Running time:", runningTime.__str__()
  logging.info("Time to execute: " + runningTime.__str__())
  p2 = subprocess.call(['combine2613', 'fort.13', 'fort.26', 'fit.13'])
  shutil.copy('fort.18', prependStamp + '.fort.18')
  shutil.copy('fort.26', prependStamp + '.fort.26')
  shutil.copy('fit.13', prependStamp + '.fit.13')
  pass

if __name__ == '__main__':
  main()


# # TODO parse the body of fort.13 and fit.13 files and report any discrepancies. 
# # TODO Create pdf of full velocity plot.
# # TODO find some way to parse things that won't change (fit results, time, date) plus things

# -----------------------
# Higher level: physical components are the structures, the particular metals are not important. Abundance ratios are interesting.
# End-run analysis should be a separate program so can be rerun separately/repeatedly ?
# stochastic shifting of every fit variable and restart of fitting process.
# -----------------------
# data = [{"running time": runningTime}]
# json

# Parse datafile -- report/log if blind or unblind. 

