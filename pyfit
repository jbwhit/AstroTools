#!/usr/bin/env python
# pyfit.py
# 
# The purpose of this program is to attempt to make fitting absorption systems 
# with vpfit reproducible, and easier. Several decisions were made that could
# be argued are steps in the wrong direction. Let me know if you have any better
# ideas or suggestions. (You can probably Google me and vpfit and find out my
# current information).
# 
# Copyright 2012 Jonathan Whitmore 
# Distributed under the Boost Software License, Version 1.0.
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated
# by a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
# NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
# DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,
# WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# 
import os
import sys
import re
import shutil
import argparse
import shlex
import datetime
import time 
import pprint
import glob
import logging
import readline
import subprocess as subprocess
import difflib
from ConfigParser import SafeConfigParser
import simplejson as json

latestAtomdat = 'MM_VPFIT_2012-06-05.dat' # Update this. 

# Known limitations
# datafiles must not have spaces in their names. 
# qa is the flag for fitting alpha.

def fort18Check(inFile, passDictionary):
  """
  Runs the inFile through a series of checks to test if anything 
  bad has happened during the fit. 
  """
  # check (chi-sq going down every iteration; error not "too big"; value not "too big")
  # TODO: levelUp flag; continueFlag; etc. 
  iterationArray = []
  starts = []
  rejected = []
  hessian = []
  dropped = []
  with open(inFile, 'r') as f18:
    for line in f18.read().splitlines():
      if re.search('iteration', line):
        iterationArray.append(line.split()[2])
        starts.append(line.split()[4])
      if re.search('rejected', line):
        rejected.append(line)
      if re.search('hessian', line):
        hessian.append(line)
      if re.search('iteration', line):
        dropped.append(line)
  if max(set(starts)) >= 2:
    logging.warning("Initial fort.18 restarts: " + max(set(starts)))
  if int(iterationArray[-1]) == 125:
    passDictionary['iterations125'] = True
    logging.info("125 iterations.")
  else:
    continueFlag = False
  pass

def fort26check():
  """docstring for fort26check"""
  # Errors in fort.26 to parse for:
  # Stats: ... errs 
  # Stats: ... BAD
  # # echo "iter;  chisq;    Npix;   DoF; Ndropped; Filename; level; alpha-fit"
  # awk '/Stat/{printf("%3i  %3.7f %6i %6i %6i     %s \n"), $3, $4, $5, $6, $8, "'$TIMESTAMP'" "/" FILENAME}' fit.13 | paste - fit.log > temp
  # awk '/qa/{print "alpha"}' fit.13 | paste temp - > summary.txt
  pass

def bump(inFile, outFile):
  """
  Takes inFile and bumps the values of the bvalues that have hit the limit.
  """
  with open(inFile, 'r') as unBumped, open(outFile, 'w') as bumpFile:
    for line in unBumped.readlines():
      bumpFile.write(re.sub(r' 0.5000', ' 0.6250', line))
  pass

def runVPFIT(vpfitExecutable, FITTINGPARAMETERS, prependStamp):
  """docstring for runVPFIT"""
  print "Running... "
  shutil.copy('command.fort.13', prependStamp + '.fort.13')
  startTime = datetime.datetime.now()
  proc = subprocess.Popen([vpfitExecutable], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
  result = proc.communicate(input=FITTINGPARAMETERS)
  endTime = datetime.datetime.now()
  runningTime = endTime - startTime
  print "Running time:", runningTime.__str__()
  logging.info("Time to execute: " + runningTime.__str__())
  p2 = subprocess.call(['combine2613', 'fort.13', 'fort.26', 'fit.13'])
  shutil.copy('fort.18', prependStamp + '.fort.18')
  shutil.copy('fort.26', prependStamp + '.fort.26')
  shutil.copy('fit.13', prependStamp + '.fit.13')
  pass

def main():
  TIMESTAMP = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S")
  print TIMESTAMP

  parser = argparse.ArgumentParser(description='Run vpfit with specified fitting parameters.')
  parser.add_argument('input13', action="store", default='fort.13', type=str) # Positional (feed in the fort.13-formatted file).
  parser.add_argument('--noContinue', action="store_true", default=False, help='Will not continue with alpha fitting.')
  parser.add_argument('--noLevelUp', action="store_true", default=False, help='Will not level up through the fitLevels.')
  parser.add_argument('--noComment', action="store_true", default=False, help='Turn off comment prompt.')
  parser.add_argument('--noConfigs', action="store_true", default=False, help='Will not use the config files.')
  parser.add_argument('--noPlot', action="store_true", default=False, help='Will not make pdf plots.')
  parser.add_argument('--noBump', action="store_true", default=False, help='Will not bump the fort.13 off the min values.')
  parser.add_argument('--vpfit', action="store", dest="vpfitVersion", default='9.5', type=str, help='Which version of vpfit to use.')
  parser.add_argument('--fitLevel', choices=('L1', 'L2', 'L3', 'L4', 'L5'), default='L5', 
                      help='The VPFIT parameter step sizes to use.')
  parser.add_argument('--dataFile', action="store", default='blind', help='data file to use.')
  parser.add_argument('--maxRuns', action="store", default=12, type=int, help='Max runs before quitting.')
  parser.add_argument('--fitSetupDirectory', dest="fitSetupDirectory", default='notSet', help='Location of atom.dat, vp_setup.dat, etc.')
  parser.add_argument('--atomdat', choices=('isoAtomFile', 'atomFile'), default='atomFile', help='atom.dat choices')
  parser.add_argument('--version', action='version', version='%(prog)s 0.02')
  args = parser.parse_args()
  
  if args.vpfitVersion == ("9.5" or "95"):
    print "VPFIT version: ", args.vpfitVersion
    vpfitExecutable = 'vpfit95'
  elif args.vpfitVersion == ("10.0" or "10"):
    print "VPFIT version: ", 
    vpfitExecutable = 'vpfit10'
  else:
    print "What VPFIT version are you wanting to use?"
  
  flagDict = {}  
  flagDict['noContinue'] = args.noContinue
  flagDict['noLevelUp'] = args.noLevelUp
  flagDict['noComment'] = args.noComment
  flagDict['noConfigs'] = args.noConfigs
  flagDict['iterations125'] = False

  os.makedirs(TIMESTAMP)
  parentDirectory = os.getcwd() + '/'
  os.chdir(TIMESTAMP)
  fitDirectory = os.getcwd() + '/'

  # Create a fitting log.
  logging.basicConfig(filename=TIMESTAMP + '.log', level=logging.DEBUG)
  for arg, value in sorted(vars(args).items()):
    logging.info("Argument %s: %r", arg, value)

  logging.info("parentDirectory: " + parentDirectory)
  logging.info("fitDirectory: " + fitDirectory)

  if args.noConfigs == True:
    print "Not using config files."
    print "Need to know locations of setup files and data files."
  else:
    parser = SafeConfigParser()
    candidates = glob.glob(parentDirectory + 'config*')
    found = parser.read(candidates)
    print "Using these config files:"
    for configfile in set(found):
      print "  ", configfile
      logging.info("config loaded: " + configfile)
    setupDir = parser.get('machine', 'setupdir') + '/'
    atomDatFile = parser.get('update', args.atomdat)
    shutil.copy(setupDir + atomDatFile, fitDirectory)
    shutil.copy(setupDir + 'vp_setup.dat', fitDirectory)
    shutil.copy(setupDir + 'vp_splot.dat', fitDirectory)
    dataDirectory = parser.get('data', 'dataDirectory') + '/'
    os.symlink(atomDatFile, 'atom.dat') # create symbolic link to atom.dat in fitting directory.

  shutil.copy(parentDirectory + args.input13, fitDirectory + "input.fort.13")
  if args.input13 != "input.fort.13":
    shutil.copy(parentDirectory + args.input13, fitDirectory + "input.fort.13")

  if args.noBump:
    shutil.copy('input.fort.13', fitDirectory + 'bump.13')
  else:
    bump('input.fort.13', 'bump.13')

  d = difflib.Differ()
  diff = difflib.unified_diff(open('input.fort.13', 'r').read().split('\n'), open('bump.13','r').read().split('\n'), n=0)
  print '\n'.join(diff)
  diff = difflib.unified_diff(open('input.fort.13', 'r').read().split('\n'), open('bump.13','r').read().split('\n'), n=0)
  logging.info( "diff begin " )
  logging.info( '\n'.join(diff))
  logging.info( "diff end " )

  inputHandle = open('bump.13', 'r').read().split('\n')
  beginHead, beginBody = False, False
  try: 
    with open('head.13', 'w') as head, open('body.13', 'w') as body:
      for line in inputHandle:
        if (not line.strip().startswith('!') and line.strip() != ''): # Ignore comments and empty lines.
          if line.startswith('   *'):
            beginHead = True
          if beginHead == True:
            print >>head, line
          if beginBody == True:
            print >>body, line
          if line.startswith('  *'):
            beginHead = False
            beginBody = True
  except: 
    print "Splitting the input file failed."

  # combine head and body into fort.13
  with open('fort.13', 'w') as outFile:
    with open('head.13','r') as head, open('body.13','r') as body:
      outFile.write(head.read())
      outFile.write(body.read())

  # parse input fort.13 for data files needed. 
  dataFiles = []
  with open ('head.13', 'r') as head:
    for line in head.read().split('\n'):
      if len(line.split()) > 4:
        dataFiles.append(line.split()[0])
  logging.info("Data files used: ")
  for datafile in set(dataFiles):
    os.symlink(dataDirectory + datafile, fitDirectory + datafile)
    logging.info(datafile)

  # Parses the body of the body.13 for any anomalies.
  p = subprocess.call('fort13flagcheck') # waits for return.

  # Create dictionary of all level strings; use args.fitLevel as key.
  fitLevelDictionary = {}
  fitLevelDictionary["L1"] = "f\nil\ncs\n2.e-4 100.0 2.e-4\nn\n0.01 \nb\n0.2 \nz\n2.e-6\nx4\n5.e-6\n\n\nfort.13\nn\nn\n\n"
  fitLevelDictionary["L2"] = "f\nil\ncs\n2.e-5 100.0 2.e-5\nn\n0.005\nb\n0.1 \nz\n2.e-7\nx4\n5.e-6\n\n\nfort.13\nn\nn\n\n"
  fitLevelDictionary["L3"] = "f\nil\ncs\n2.e-6 100.0 2.e-6\nn\n0.002\nb\n0.05\nz\n2.e-7\nx4\n5.e-7\n\n\nfort.13\nn\nn\n\n"
  fitLevelDictionary["L4"] = "f\nil\ncs\n2.e-7 100.0 2.e-7\nn\n0.002\nb\n0.05\nz\n2.e-7\nx4\n5.e-7\n\n\nfort.13\nn\nn\n\n"
  fitLevelDictionary["L5"] = "f\nil\ncs\n1.e-8 100.0 1.e-8\nn\n0.002\nb\n0.05\nz\n2.e-7\nx4\n5.e-7\n\n\nfort.13\nn\nn\n\n"

  FITTINGPARAMETERS = fitLevelDictionary[args.fitLevel]
  levelArray = sorted(fitLevelDictionary.keys())
  maxRuns = args.maxRuns
  for level, s in enumerate(levelArray):
    if args.fitLevel in s:
      currentLevel = level
  maxLevel = levelArray[-1]
  print "Max fitting level is: ", maxLevel
  
  # Create symbolic link to fitting directory.
  executableLink = subprocess.Popen(['which', vpfitExecutable], stdout=subprocess.PIPE)
  os.symlink(executableLink.communicate()[0].strip(), fitDirectory + 'vpfit')
  logging.info('VPFIT version: ' + args.vpfitVersion)
  logging.info('VPFIT executable: ' + vpfitExecutable)

  # Change to use current directory settings. 
  os.environ['ATOMDIR'] = 'atom.dat'
  os.environ['VPFSETUP'] = 'vp_setup.dat'
  os.environ['VPFPLOTS'] = 'vp_splot.dat'
  logging.info("PATH for ATOMDIR:  " + os.environ['ATOMDIR'])
  logging.info("PATH for VPFSETUP: " + os.environ['VPFSETUP'])
  logging.info("PATH for VPFPLOTS: " + os.environ['VPFPLOTS'])

  with open('command.info', 'w') as fh:
    print >>fh, "! ATOMDIR:" + atomDatFile
    print >>fh, "! runCommand: printf " + repr(FITTINGPARAMETERS) + " | " + vpfitExecutable

  # cat command.info fort.13 > command.fort.13
  with open('command.fort.13', 'w') as outFile:
    with open('command.info', 'r') as com, open('fort.13', 'r') as fort13:
      outFile.write(com.read())
      outFile.write(fort13.read())

  logging.info("Fitting Parameters: " + repr(FITTINGPARAMETERS))
  print TIMESTAMP
  if args.noComment == False:
    initialFitComment = raw_input("Comment: ")
    logging.info(initialFitComment)

  print TIMESTAMP
  print "Running... "
  proc = subprocess.Popen([vpfitExecutable], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
  result = proc.communicate(input=FITTINGPARAMETERS)
  endTime = datetime.datetime.now()
  runningTime = endTime - startTime
  print "Running time:", runningTime.__str__()
  logging.info("Time to execute: " + runningTime.__str__())

  with open('command.fort.26', 'w') as outFile:
    with open('command.info', 'r') as com, open('fort.26', 'r') as fort26:
      outFile.write(com.read())
      outFile.write(fort26.read())

  p2 = subprocess.call(['combine2613', 'fort.13', 'fort.26', 'fit.13'])

  # copy all fort.* to TIMESTAMP.fort.* 
  shutil.copy('fort.18', TIMESTAMP + '.fort.18')
  shutil.copy('fort.26', TIMESTAMP + '.fort.26')
  shutil.copy('fit.13', TIMESTAMP + '.fit.13')

  # ===================
  # = Analyze fort.18 =
  # ===================
  # if 125 iterations and no other errors
  # check (chi-sq going down every iteration; error not "too big"; value not "too big")
  # TODO: levelUp flag; continueFlag; etc. 
  iterationArray = []
  starts = []
  rejected = []
  hessian = []
  dropped = []
  with open('fort.18', 'r') as f18:
    for line in f18.read().splitlines():
      if re.search('iteration', line):
        iterationArray.append(line.split()[2])
        starts.append(line.split()[4])
      if re.search('rejected', line):
        rejected.append(line)
      if re.search('hessian', line):
        hessian.append(line)
      if re.search('iteration', line):
        dropped.append(line)

  if max(set(starts)) >= 2:
    logging.warning("Initial fort.18 restarts: " + max(set(starts)))
  if int(iterationArray[-1]) == 125:
    continueFlag = True
    flag125hit = True
    logging.info("Automated continue fitting to begin.")
  else:
    continueFlag = False
  # Errors in fort.26 to parse for:
  # Stats: ... errs 
  # Stats: ... BAD

  # # echo "iter;  chisq;    Npix;   DoF; Ndropped; Filename; level; alpha-fit"
  # awk '/Stat/{printf("%3i  %3.7f %6i %6i %6i     %s \n"), $3, $4, $5, $6, $8, "'$TIMESTAMP'" "/" FILENAME}' fit.13 | paste - fit.log > temp
  # awk '/qa/{print "alpha"}' fit.13 | paste temp - > summary.txt

  CONTINUETIMESTAMP = []
  CONTINUETIMESTAMP.append(TIMESTAMP)

  # pseudocode
  # if flag125hit == True:
  #   rerun maxRuns
  # if scaleUp == True:
  #   continueScale()

  maxRuns = 12
  RUNCOUNT = 1
  for level, s in enumerate(levelArray):
    if args.fitLevel in s:
      currentLevel = level

  # while (RUNCOUNT < maxRuns) and (continueFlag == True):
  while (RUNCOUNT < maxRuns) and (continueFlag == True):
    RUNCOUNT += 1
    if (flag125hit == False) and (levelArray[currentLevel] != levelArray[-1]):
      currentLevel += 1
      print "Leveling up\nCurrent level: ", currentLevel
      RUNCOUNT = 1
      FITTINGPARAMETERS = fitLevelDictionary[levelArray[currentLevel]]
      print "Fitting Parameters: " + repr(FITTINGPARAMETERS)
      logging.info("Leveled up!")
      logging.info("Fitting Parameters: " + repr(FITTINGPARAMETERS))
    NEWTIMESTAMP = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S")
    logging.info("Beginning run: " + str(RUNCOUNT) + " at " + NEWTIMESTAMP)
    print "Beginning run: " + str(RUNCOUNT) + " at " + NEWTIMESTAMP
    CONTINUETIMESTAMP.append(NEWTIMESTAMP)
    
    
    bump(CONTINUETIMESTAMP[-2] + '.fit.13', 'fort.13')
    # with open(CONTINUETIMESTAMP[-2] + '.fit.13', 'r') as unbumped, open('fort.13', 'w') as bumpFile:
    #   for line in unbumped.readlines():
    #     bumpFile.write(re.sub(r' 0.5000', ' 0.6250', line))
    
    shutil.copy('fort.13', CONTINUETIMESTAMP[-1] + '.fort.13') 
    print NEWTIMESTAMP, ": continuing with run: ", RUNCOUNT
    proc = subprocess.Popen([vpfitExecutable], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    result = proc.communicate(input=FITTINGPARAMETERS)
    shutil.copy('fort.18', CONTINUETIMESTAMP[-1] + '.fort.18') # vpfit9.5 does weird things to the fort.18
    shutil.copy('fort.26', CONTINUETIMESTAMP[-1] + '.fort.26')
    p2 = subprocess.call(['combine2613', 'fort.13', 'fort.26', 'fit.13'])
    shutil.copy('fit.13', CONTINUETIMESTAMP[-1] + '.fit.13')
    with open('fort.18', 'r') as f18:
      for line in f18.read().splitlines():
        if re.search('iteration', line):
          iterationArray.append(line.split()[2])
    if int(iterationArray[-1]) == 125:
      continueFlag = True
      flag125hit = True
    else:
      if currentLevel == maxlevel:
        continueFlag = False
      flag125hit = False

  if RUNCOUNT == maxRuns:
    print "Not converged yet. Runs before stopping: ", RUNCOUNT
    logging.warning("Not converged yet. Runs before stopping: " + str(RUNCOUNT))
  else:
    print "It took ", RUNCOUNT, " runs to converge."
    logging.info("It took " + str(RUNCOUNT) + " runs to converge.")

  if args.noPlot == False: 
    print "Creating fit comparison plots."
    proc = subprocess.Popen(['plotfit', CONTINUETIMESTAMP[-1], 'input.fort.13', CONTINUETIMESTAMP[-1] + ".fit.13"])

  alphafit = False
  with open(CONTINUETIMESTAMP[-1] + '.fit.13', 'r') as finalFit13:
    if re.search('qa', finalFit13.read()):
      alphafit = True # If already started out fitting for alpha

  # Add argparse option to say which fittingflag would fit for alpha
  # Add argparse option to not fit for alpha
  if alphafit == False: 
    print "Fitting for alpha..."
    p3 = subprocess.call(['convert13-13da', CONTINUETIMESTAMP[-1] + '.fit.13'])
    NEWTIMESTAMP = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S")
    CONTINUETIMESTAMP.append( NEWTIMESTAMP + '.alpha')
    shutil.move('alpha.13', NEWTIMESTAMP + '.alpha.fit.13')
    print NEWTIMESTAMP + '.alpha.fit.13'
    # Reusing above code.
    RUNCOUNT = 0
    continueFlag = True
    FITTINGPARAMETERS = fitLevelDictionary[maxlevel]
    while (RUNCOUNT < maxRuns) and (continueFlag == True):
      RUNCOUNT += 1
      NEWTIMESTAMP = datetime.datetime.now().strftime("%Y.%m.%d.%H.%M.%S")
      logging.info("Beginning alpha run: " + str(RUNCOUNT) + " at " + NEWTIMESTAMP)
      print "Beginning alpha run: " + str(RUNCOUNT) + " at " + NEWTIMESTAMP
      CONTINUETIMESTAMP.append(NEWTIMESTAMP)
      with open(CONTINUETIMESTAMP[-2] + '.fit.13', 'r') as unbumped, open('fort.13', 'w') as bumpFile: # which file is this? 
        print "List: ", CONTINUETIMESTAMP
        print "File to bump: ", CONTINUETIMESTAMP[-2] + '.fit.13'
        for line in unbumped.readlines():
          bumpFile.write(re.sub(r' 0.5000', ' 0.6250', line))
      shutil.copy('fort.13', CONTINUETIMESTAMP[-1] + '.fort.13') 
      print "Continuing with alpha run: ", RUNCOUNT
      proc = subprocess.Popen([vpfitExecutable], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
      result = proc.communicate(input=FITTINGPARAMETERS)
      shutil.copy('fort.18', CONTINUETIMESTAMP[-1] + '.fort.18') # vpfit9.5 does weird things to the fort.18
      shutil.copy('fort.26', CONTINUETIMESTAMP[-1] + '.fort.26')
      p2 = subprocess.call(['combine2613', 'fort.13', 'fort.26', 'fit.13'])
      shutil.copy('fit.13', CONTINUETIMESTAMP[-1] + '.fit.13')
      with open('fort.18', 'r') as f18:
        for line in f18.read().splitlines():
          if re.search('iteration', line):
            iterationArray.append(line.split()[2])
      if int(iterationArray[-1]) == 125:
        continueFlag = True
      else:
        continueFlag = False
  else:
    print "Finished."

  print "Exited gracefully."
  pass

if __name__ == '__main__':
  main()


# # TODO parse the body of fort.13 and fit.13 files and report any discrepancies. 
# # TODO Create pdf of full velocity plot.
# # TODO find some way to parse things that won't change (fit results, time, date) plus things

# -----------------------
# Higher level: physical components are the structures, the particular metals are not important. Abundance ratios are interesting.
# End-run analysis should be a separate program so can be rerun separately/repeatedly ?
# stochastic shifting of every fit variable and restart of fitting process.
# -----------------------
# data = [{"running time": runningTime}]
# json

# Parse datafile -- report/log if blind or unblind. 

